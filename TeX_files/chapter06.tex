\chapter{Minimum Action Path}
\maketitle

\subsection*{4 December 2017}
I'm noticing now just how long it's going to take to compute a minimum action pathway in 4 dimensions inside the $^{294}Og$ barrier. I've left the thing running for at least 80 hours on 14 cores on iCER and it's only up to about $Q_{20}=25$ (it traverses the path in steps along $Q_{20}$). First of all, it actually takes a fair bit of time to even continue where it left off - far more than I feel like it should, like it took over an hour for the dataset that I had, when I feel like something like that shouldn't take more than a couple of minutes. But even after that, it still takes a long time. And I did some back-of-the-envelope math, and it makes sense: the surface I have spans $Q_{20}\in[-20,162], \lambda_2\in[40,0], Q_{22}\in[3,45], Q_{30}\in[0,45]$ - that's 14840934 points! Of course, we don't use quite all of those, since the algorithm is at least somewhat intelligent. But even still, it is possible to have a ``layer'' of $\sim40^3=64000$ points to check for a single value of $Q_{20}$ (for the method we use to find the path, I believe that is the most we can break down the problem), each with $(2x_{span}+1)(2y_{span}+1)(2z_{span}+1)-1$ ``next points'' to check.

I've been using OpenMP shared-memory parallelism thus far, but that's limited to the number of cores on a node. To do this quickly, it looks like it's going to take a \textit{lot} more processors, which means distributed memory parallelism. And actually, I was thinking, this might even be a case where GPUs might be able to do the job quickly. You feed in the uninterpolated data, and then the GPUs fairly quickly should be able to interpolate the surface, and maybe even action ``steps,'' and then you can find the best path and it shouldn't be too hard by then.
